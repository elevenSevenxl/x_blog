import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as s,f as e}from"./app-7c7e6589.js";const o={},p=e(`<hr><blockquote><p>shallowRef 和 markRaw 是 Vue3 中的两个函数，用于处理响应式数据。</p></blockquote><ul><li>shallowRef：<br> 用于创建一个响应式的数据引用（Ref）。<br> 当包装的值发生变化时，会触发视图的重新渲染。<br> 但是，如果包装的值是一个对象或数组，则不会对其进行递归地深层监听，只会监听其第一层的变化。<br> 这意味着，如果对象或数组内部的属性或元素发生变化，视图不会重新渲染。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> shallowRef <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> shallowObj <span class="token operator">=</span> <span class="token function">shallowRef</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>

shallowObj<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// 视图更新</span>

<span class="token comment">// 下面的操作不会触发视图更新</span>
shallowObj<span class="token punctuation">.</span>value<span class="token punctuation">.</span>innerValue <span class="token operator">=</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>markRaw：<br> 用于创建一个非响应式的数据，即不会被 Vue 追踪其变化。<br> 适用于那些不希望被 Vue 追踪其变化的数据，比如第三方库的对象或不需要响应式的临时数据。<br> 使用 markRaw 包装的数据，无论其如何变化，都不会触发视图的重新渲染。</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> markRaw <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;vue&#39;</span>

<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token function">markRaw</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

obj<span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token number">2</span> <span class="token comment">// 视图不会更新</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-warning line-numbers-mode" data-ext="warning"><pre class="language-warning"><code>需要注意的是，使用markRaw包装的数据将失去响应性，不再受Vue的追踪，因此需要谨慎使用。一般来说，应该优先使用响应式的数据来实现视图的更新。只有在某些特殊情况下，才会使用markRaw来明确指定某些数据不需要被追踪。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>使用场景</li></ul><p>动态组件 tab 切换</p><p>1.在 Vue2 的时候 is 是通过组件名称切换的 在 Vue3 setup 是通过组件实例切换的</p><p>2.如果你把组件实例放到 Reactive Vue 会给你一个警告 runtime-core.esm-bundler.js:38 [Vue warn]: Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with <code>markRaw</code> or using <code>shallowRef</code> instead of <code>ref</code>.<br> Component that was made reactive:</p><p>这是因为 reactive 会进行 proxy 代理 而我们组件代理之后毫无用处，为了节省性能开销，推荐我们使用 shallowRef 或者 markRaw 跳过 proxy 代理。</p><hr>`,13),t=[p];function l(c,r){return n(),s("div",null,t)}const d=a(o,[["render",l],["__file","shallowRef 和 markRaw 的区别.html.vue"]]);export{d as default};
